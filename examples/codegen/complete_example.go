package main

//go:generate jetorm-gen -type=Product -interface=ProductRepository -input=complete_example.go -output=product_repository_gen.go -comments=true

import (
	"context"
	"time"
)

// Product represents a product entity with comprehensive tags
type Product struct {
	ID          int64     `db:"id" jet:"primary_key,auto_increment"`
	SKU         string    `db:"sku" jet:"unique,not_null,index:idx_sku"`
	Name        string    `db:"name" jet:"not_null,size:255"`
	Description string    `db:"description" jet:"type:text"`
	Price       float64   `db:"price" jet:"type:decimal(10,2),not_null,check:price >= 0"`
	Stock       int       `db:"stock" jet:"not_null,default:0,check:stock >= 0"`
	CategoryID  int64     `db:"category_id" jet:"foreign_key:categories.id,on_delete:cascade"`
	Status      string    `db:"status" jet:"default:'active',index:idx_status"`
	CreatedAt   time.Time `db:"created_at" jet:"auto_now_add"`
	UpdatedAt   time.Time `db:"updated_at" jet:"auto_now"`
}

// ProductRepository defines the repository interface for Product
// Custom query methods will be auto-generated by jetorm-gen
type ProductRepository interface {
	// Base repository methods are inherited from jetorm.Repository[Product, int64]
	
	// Find operations
	FindBySKU(ctx context.Context, sku string) (*Product, error)
	FindByCategoryID(ctx context.Context, categoryID int64) ([]*Product, error)
	FindByStatus(ctx context.Context, status string) ([]*Product, error)
	FindByPriceGreaterThan(ctx context.Context, price float64) ([]*Product, error)
	FindByPriceBetween(ctx context.Context, minPrice, maxPrice float64) ([]*Product, error)
	FindByStatusIn(ctx context.Context, statuses []string) ([]*Product, error)
	FindByStockLessThan(ctx context.Context, stock int) ([]*Product, error)
	
	// Find with ordering
	FindByStatusOrderByPriceAsc(ctx context.Context, status string) ([]*Product, error)
	FindByCategoryIDOrderByCreatedAtDesc(ctx context.Context, categoryID int64) ([]*Product, error)
	
	// Find first/top
	FindFirstByStatus(ctx context.Context, status string) (*Product, error)
	FindTop10ByStatusOrderByPriceDesc(ctx context.Context, status string) ([]*Product, error)
	
	// Count operations
	CountByStatus(ctx context.Context, status string) (int64, error)
	CountByCategoryID(ctx context.Context, categoryID int64) (int64, error)
	
	// Exists operations
	ExistsBySKU(ctx context.Context, sku string) (bool, error)
	ExistsByCategoryID(ctx context.Context, categoryID int64) (bool, error)
	
	// Delete operations
	DeleteBySKU(ctx context.Context, sku string) error
	DeleteByStatus(ctx context.Context, status string) error
	
	// Custom implementation (manually written)
	FindLowStockProducts(ctx context.Context, threshold int) ([]*Product, error)
}

// Example usage (this would be in a separate file)
func exampleUsage() {
	// This demonstrates how the generated repository would be used
	// In a real application, you would:
	// 1. Run: go generate ./...
	// 2. Use the generated ProductRepository implementation
	
	_ = context.Background()
	// db := core.MustConnect(config)
	// repo := NewProductRepository(db)
	// 
	// product, err := repo.FindBySKU(ctx, "SKU-123")
	// products, err := repo.FindByStatusOrderByPriceAsc(ctx, "active")
	// count, err := repo.CountByStatus(ctx, "active")
}

