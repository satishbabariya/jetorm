package generator

import (
	"fmt"
	"strings"
	"text/template"
)

// Templates for code generation

var repositoryTemplate = `
package {{.PackageName}}

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/satishbabariya/jetorm/core"
)

// {{.RepositoryName}} is the generated repository implementation for {{.EntityName}} entities.
// This code is auto-generated by jetorm-gen. Do not edit manually.
type {{.RepositoryName}} struct {
	*core.BaseRepository[{{.EntityName}}, {{.IDType}}]
}

// New{{.RepositoryName}} creates a new {{.RepositoryName}} repository instance.
func New{{.RepositoryName}}(db *core.Database) (*{{.RepositoryName}}, error) {
	baseRepo, err := core.NewBaseRepository[{{.EntityName}}, {{.IDType}}](db)
	if err != nil {
		return nil, err
	}
	return &{{.RepositoryName}}{
		BaseRepository: baseRepo,
	}, nil
}
`

var methodTemplate = `
// {{.MethodName}} implements the query method
func (r *{{.RepositoryName}}) {{.MethodName}}(ctx context.Context{{.Parameters}}) {{.ReturnType}} {
	{{.Body}}
}
`

// TemplateData holds data for template rendering
type TemplateData struct {
	PackageName    string
	EntityName     string
	RepositoryName string
	IDType         string
	Methods        []MethodTemplateData
}

// MethodTemplateData holds data for method template rendering
type MethodTemplateData struct {
	MethodName string
	Parameters string
	ReturnType string
	Body       string
}

// GenerateRepositoryCode generates repository code using templates
func GenerateRepositoryCode(data TemplateData) (string, error) {
	tmpl, err := template.New("repository").Parse(repositoryTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse repository template: %w", err)
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute repository template: %w", err)
	}

	// Generate methods
	methodTmpl, err := template.New("method").Parse(methodTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse method template: %w", err)
	}

	for _, method := range data.Methods {
		buf.WriteString("\n")
		if err := methodTmpl.Execute(&buf, method); err != nil {
			return "", fmt.Errorf("failed to execute method template: %w", err)
		}
	}

	return buf.String(), nil
}

// FormatCode formats generated code
func FormatCode(code string) string {
	// Basic formatting - would use go/format in production
	lines := strings.Split(code, "\n")
	var formatted []string
	indent := 0

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed == "" {
			formatted = append(formatted, "")
			continue
		}

		// Decrease indent on closing braces
		if strings.HasPrefix(trimmed, "}") {
			indent--
		}

		// Add indented line
		indented := strings.Repeat("\t", indent) + trimmed
		formatted = append(formatted, indented)

		// Increase indent on opening braces
		if strings.HasSuffix(trimmed, "{") {
			indent++
		}
	}

	return strings.Join(formatted, "\n")
}

