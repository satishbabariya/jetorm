package main

import (
	"flag"
	"fmt"
	"go/parser"
	"go/token"
	"os"
	"strings"

	"github.com/satishbabariya/jetorm/generator"
)

func main() {
	// Check for commands
	if len(os.Args) > 1 {
		command := os.Args[1]
		args := os.Args[2:]
		
		// Handle help
		if command == "help" || command == "-h" || command == "--help" {
			printUsage()
			return
		}
		
		// Execute command
		if err := executeCommand(command, args); err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			os.Exit(1)
		}
		return
	}

	// Parse configuration
	cfg, err := parseConfig()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		flag.Usage()
		os.Exit(1)
	}

	// Get package name
	pkgName := cfg.OutputPackage
	if pkgName == "" {
		pkgName = extractPackageName(cfg.InputFile)
	}

	// Parse interface to extract methods
	parser := generator.NewParser()
	interfaceInfo, err := parser.ParseInterface(cfg.InputFile, cfg.InterfaceName)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing interface: %v\n", err)
		os.Exit(1)
	}

	if interfaceInfo == nil {
		fmt.Fprintf(os.Stderr, "Error: interface %s not found in %s\n", cfg.InterfaceName, cfg.InputFile)
		os.Exit(1)
	}

	// Extract custom query methods
	customMethods := interfaceInfo.FindCustomMethods()
	if len(customMethods) == 0 {
		fmt.Fprintf(os.Stderr, "Warning: No custom query methods found in interface\n")
	}
	
	// Generate repository code
	code, err := generateRepositoryCode(pkgName, cfg.EntityType, customMethods, cfg)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating code: %v\n", err)
		os.Exit(1)
	}

	// Write to output file
	if err := os.WriteFile(cfg.OutputFile, []byte(code), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated repository code: %s\n", cfg.OutputFile)
	
	// Generate tests if requested
	if cfg.GenerateTests {
		testCode, err := generateTestCode(pkgName, cfg.EntityType, customMethods, cfg)
		if err == nil {
			testFile := cfg.OutputFile[:len(cfg.OutputFile)-3] + "_test.go"
			if err := os.WriteFile(testFile, []byte(testCode), 0644); err == nil {
				fmt.Printf("Successfully generated test file: %s\n", testFile)
			}
		}
	}
}


// extractPackageName extracts package name from a Go file
func extractPackageName(filePath string) string {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return "main"
	}
	return f.Name.Name
}

// generateRepositoryCode generates the complete repository implementation
func generateRepositoryCode(pkgName, entityName string, customMethods []generator.MethodInfo, cfg *generator.Config) (string, error) {
	var buf strings.Builder

	// Write package declaration
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))

	// Write imports
	buf.WriteString(`import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/satishbabariya/jetorm/core"
)
`)

	// Determine ID type
	idType := cfg.IDType
	if idType == "" {
		idType = "int64" // Default
	}

	// Write repository struct
	repoName := fmt.Sprintf("%sRepository", entityName)
	
	// Add comments if requested
	if cfg.GenerateComments {
		buf.WriteString(fmt.Sprintf(`
// %s is the generated repository implementation for %s entities.
// This code is auto-generated by jetorm-gen. Do not edit manually.
type %s struct {
	*core.BaseRepository[%s, %s]
}

// New%s creates a new %s repository instance.
func New%s(db *core.Database) (*%s, error) {
	baseRepo, err := core.NewBaseRepository[%s, %s](db)
	if err != nil {
		return nil, err
	}
	return &%s{
		BaseRepository: baseRepo,
	}, nil
}
`, repoName, entityName, repoName, entityName, idType, repoName, repoName, repoName, repoName, entityName, idType, repoName))
	} else {
		buf.WriteString(fmt.Sprintf(`
type %s struct {
	*core.BaseRepository[%s, %s]
}

func New%s(db *core.Database) (*%s, error) {
	baseRepo, err := core.NewBaseRepository[%s, %s](db)
	if err != nil {
		return nil, err
	}
	return &%s{
		BaseRepository: baseRepo,
	}, nil
}
`, repoName, entityName, idType, repoName, repoName, entityName, idType, repoName))
	}

	// Generate custom query methods
	// Note: This is a simplified version that generates method stubs
	// In a full implementation, we'd use go/types to load the entity type
	// and generate complete implementations using the analyzer
	
	for _, methodInfo := range customMethods {
		if generator.IsQueryMethod(methodInfo.Name) {
			// Generate a method stub that will be implemented later
			// or use runtime analysis
			methodCode := generateMethodStub(methodInfo, entityName)
			buf.WriteString("\n")
			buf.WriteString(methodCode)
			buf.WriteString("\n")
		}
	}

	return buf.String(), nil
}

// generateTestCode generates test code for the repository
func generateTestCode(pkgName, entityName string, customMethods []generator.MethodInfo, cfg *generator.Config) (string, error) {
	var buf strings.Builder
	
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
	buf.WriteString(`import (
	"context"
	"testing"
)
`)
	
	repoName := fmt.Sprintf("%sRepository", entityName)
	buf.WriteString(fmt.Sprintf(`
func Test%s(t *testing.T) {
	// TODO: Implement tests for %s
	t.Skip("Tests not yet implemented")
}
`, repoName, repoName))
	
	return buf.String(), nil
}

// generateMethodStub generates a method stub for a query method
func generateMethodStub(methodInfo generator.MethodInfo, entityName string) string {
	var buf strings.Builder
	
	// Build parameter list
	var params []string
	for _, param := range methodInfo.Parameters {
		if param.Name != "" {
			params = append(params, fmt.Sprintf("%s %s", param.Name, param.Type))
		} else {
			params = append(params, param.Type)
		}
	}
	paramsStr := strings.Join(params, ", ")
	
	// Build return list
	var returns []string
	for _, ret := range methodInfo.Returns {
		returns = append(returns, ret.Type)
	}
	returnsStr := strings.Join(returns, ", ")
	if len(returns) > 1 {
		returnsStr = "(" + returnsStr + ")"
	}
	
	// Generate method signature
	buf.WriteString(fmt.Sprintf("// %s implements the query method\n", methodInfo.Name))
	buf.WriteString(fmt.Sprintf("func (r *%sRepository) %s(ctx context.Context", entityName, methodInfo.Name))
	if paramsStr != "" {
		buf.WriteString(", " + paramsStr)
	}
	buf.WriteString(fmt.Sprintf(") %s {\n", returnsStr))
	buf.WriteString("\t// TODO: Implement query method\n")
	buf.WriteString("\t// This method should be generated using jetorm-gen with full type information\n")
	buf.WriteString("\tpanic(\"not implemented\")\n")
	buf.WriteString("}\n")
	
	return buf.String()
}

